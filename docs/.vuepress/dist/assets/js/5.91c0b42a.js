(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{192:function(t,v,a){t.exports=a.p+"assets/img/eventloop2.61bcc244.png"},193:function(t,v,a){t.exports=a.p+"assets/img/task.bcfff451.jpg"},217:function(t,v,a){"use strict";a.r(v);var s=a(0),_=Object(s.a)({},function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" Event Loop")]),t._v(" "),s("p",[s("code",[t._v("Event Loop")]),t._v(" 主要指的是 "),s("strong",[t._v("任务栈")]),t._v("，"),s("strong",[t._v("宏任务")]),t._v(" 与 "),s("strong",[t._v("微任务")]),t._v("（JS线程），"),s("strong",[t._v("同步任务")]),t._v(" 与 "),s("strong",[t._v("异步任务")]),t._v("， "),s("strong",[t._v("线程")]),t._v(" 与 "),s("strong",[t._v("进程")]),t._v("。")]),t._v(" "),s("p",[t._v("JS是一门 "),s("strong",[t._v("单线程")]),t._v(" 的语言。浏览器提供了一些 JS 引擎不具备的功能："),s("strong",[t._v("Web API")]),t._v("。它包括 "),s("code",[t._v("DOM API")]),t._v("，"),s("code",[t._v("setTimeout")]),t._v("，"),s("code",[t._v("HTTP")]),t._v("请求 等等。这些功能都可以帮助我们处理 "),s("strong",[t._v("异步、非阻塞")]),t._v(" 的操作。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(192),alt:"Event Loop"}})]),t._v(" "),s("h2",{attrs:{id:"执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),s("p",[t._v("执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。")]),t._v(" "),s("h3",{attrs:{id:"类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),s("ul",[s("li",[t._v("全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。")]),t._v(" "),s("li",[t._v("函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。")]),t._v(" "),s("li",[t._v("Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。")])]),t._v(" "),s("h3",{attrs:{id:"执行栈（调用栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行栈（调用栈"}},[t._v("#")]),t._v(" 执行栈（调用栈")]),t._v(" "),s("ul",[s("li",[t._v("当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。")]),t._v(" "),s("li",[t._v("引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。")])]),t._v(" "),s("h3",{attrs:{id:"怎么创建执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么创建执行上下文"}},[t._v("#")]),t._v(" 怎么创建执行上下文")]),t._v(" "),s("ul",[s("li",[t._v("创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段\n"),s("ul",[s("li",[t._v("创建阶段\n"),s("ul",[s("li",[t._v("this 值的决定，即我们所熟知的 This 绑定")]),t._v(" "),s("li",[t._v("创建词法环境")]),t._v(" "),s("li",[t._v("创建变量环境")])])])])])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/68799915",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript系列之执行上下文和执行栈 - 知乎"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"执行栈【任务栈、调用栈】"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行栈【任务栈、调用栈】"}},[t._v("#")]),t._v(" 执行栈【任务栈、调用栈】")]),t._v(" "),s("p",[s("strong",[t._v("执行栈")]),t._v("【call stack】是一个存储函数调用的栈结构，遵循 "),s("strong",[t._v("后进先出")]),t._v("【Last In, First Out. 即 LIFO】的原则，后执行的函数会先弹出栈。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/v2-64d2b205834d6efb56bcd506587df523_b.webp",alt:"https://pic4.zhimg.com/v2-64d2b205834d6efb56bcd506587df523_b.webp"}})]),t._v(" "),s("p",[t._v("首先全局上下文进入函数调用栈，执行 "),s("strong",[t._v("同步代码")]),t._v("。执行完同步代码后，查询任务队列里是否由 "),s("strong",[t._v("异步代码")]),t._v(" 需要执行。执行所有微任务，微任务执行完毕后。循环再次从宏任务开始，从任务队列中拿出一个执行，一直循环下去。")]),t._v(" "),s("h2",{attrs:{id:"任务队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[t._v("#")]),t._v(" 任务队列")]),t._v(" "),s("p",[t._v("在 Web API 中，一个定时器已经创建，它将会等待 1000 ms，当时间到后，这个箭头函数并不会立即被调用栈执行，它会被添加到一个队列中，我们暂且称之为 "),s("strong",[t._v("任务队列")]),t._v(" （原文中叫 Callback Queue）。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic1.zhimg.com/v2-43b3a252357af1afe3b704375a6374fc_b.webp",alt:"https://pic1.zhimg.com/v2-43b3a252357af1afe3b704375a6374fc_b.webp"}})]),t._v(" "),s("h2",{attrs:{id:"event-loop-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-2"}},[t._v("#")]),t._v(" Event Loop")]),t._v(" "),s("p",[t._v("如果 "),s("strong",[t._v("调用栈")]),t._v(" 是一个银行窗口，"),s("strong",[t._v("任务队列")]),t._v(" 中的回调函数是一个个排队办业务的人，那么 "),s("strong",[t._v("Event Loop")]),t._v(" 就是叫号系统！Event Loop 的唯一任务就是 "),s("strong",[t._v("连接任务队列和调用栈")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic1.zhimg.com/v2-ed978011aa34f83bb9bd04be07266388_b.webp",alt:"https://pic1.zhimg.com/v2-ed978011aa34f83bb9bd04be07266388_b.webp"}})]),t._v(" "),s("p",[t._v("它不停检查 "),s("strong",[t._v("调用栈")]),t._v(" 中是否有任务需要执行，如果没有，就检查 "),s("strong",[t._v("任务队列")]),t._v("，从中弹出一个任务，放入 "),s("strong",[t._v("调用栈")]),t._v(" 中，如此往复循环。")]),t._v(" "),s("h2",{attrs:{id:"进程、线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程"}},[t._v("#")]),t._v(" 进程、线程")]),t._v(" "),s("h3",{attrs:{id:"进程和线程的区别，js单线程带来的好处？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别，js单线程带来的好处？"}},[t._v("#")]),t._v(" 进程和线程的区别，js单线程带来的好处？")]),t._v(" "),s("p",[s("strong",[t._v("进程")]),t._v("就是执行中的一个程序，是操作资源分配的最小单位。"),s("strong",[t._v("线程")]),t._v("是进程中执行的一个任务，是程序执行的最小单位。")]),t._v(" "),s("p",[s("strong",[t._v("一个进程由多个线程组成")]),t._v("。进程间相互独立，一个进程下的多个线程共享资源。打开一个不同地址的游览器tab就是一个进程，里面由渲染线程，JS引擎线程，HTTP请求线程。")]),t._v(" "),s("h2",{attrs:{id:"宏任务和微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),s("h3",{attrs:{id:"宏任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[t._v("#")]),t._v(" 宏任务")]),t._v(" "),s("p",[t._v("宏任务：当前调用栈执行的任务（主代码快【同步任务】，定时器等等【异步任务】）。事件放在"),s("code",[t._v("callback queue")]),t._v("中，由事件触发线程维护。包括script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering")]),t._v(" "),s("h3",{attrs:{id:"微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[t._v("#")]),t._v(" 微任务")]),t._v(" "),s("p",[t._v("微任务：宏任务执行完，在下一个宏任务执行之前执行的任务（可以理解为回调事件，promise.then，proness.nextTick等等）。事件放在微任务队列，有 "),s("code",[t._v("javascript")]),t._v(" 引擎线程维护。\n包括process.nextTick ，promise ，MutationObserver")]),t._v(" "),s("p",[s("img",{attrs:{src:a(193),alt:"宏任务和微任务"}})]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("资料库")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/72507900",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何解释Event Loop面试官才满意？- 知乎"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/101165696",target:"_blank",rel:"noopener noreferrer"}},[t._v("动图学 JavaScript 之：事件循环（Event Loop - 知乎"),s("OutboundLink")],1)])])])])},[],!1,null,null,null);v.default=_.exports}}]);